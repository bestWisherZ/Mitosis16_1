package eventbus

/*
func GetTxMsg() message.Message {
	fromAddr := [32]byte{0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	toAddr := [32]byte{0xbf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	tx1 := types.NewTransaction(fromAddr, toAddr, uint64(1000), uint64(10000))

	msg := message.NewBlockchainMessage(topics.Tx, *tx1)
	return msg
}

func GetBlockMsg() message.Message {
	fromAddr := [32]byte{0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	toAddr := [32]byte{0xbf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}

	tx1 := chaintype.NewTransaction(fromAddr, toAddr, uint64(1000), uint64(10000))
	tx2 := chaintype.NewTransaction(toAddr, fromAddr, uint64(1000), uint64(10000))

	txs := []chaintype.Transaction{*tx1, *tx2}

	prevHash := [32]byte{0xbf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	rootHash := [32]byte{0xba, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	coinbase := [32]byte{0xba, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x36}
	h := chaintype.NewBlockHeader(1, 1, prevHash, rootHash, coinbase, coinbase, uint64(time.Now().Unix()))

	blk := chaintype.NewBlock(*h, txs)
	msg := message.NewBlockchainMessage(topics.Block, *blk)
	return msg
}

func TestNewEventBus(t *testing.T) {
	eb := New()
	assert.NotNil(t, eb)
}

func TestSubscribe(t *testing.T) {
	eb := New()

	myChan := make(chan message.Message, 10)
	cl := NewChanListener(myChan)
	assert.NotNil(t, eb.Subscribe(topics.Tx, cl))
}

func TestUnsubscribe(t *testing.T) {
	eb, myChan, id := newEB(t)
	eb.Unsubscribe(topics.Tx, id)
	errList := eb.Publish(topics.Tx, GetTxMsg())
	assert.Empty(t, errList)

	select {
	case <-myChan:
		assert.FailNow(t, "We should have not received message")
	case <-time.After(50 * time.Millisecond):
		// success
	}

}

func newEB(t *testing.T) (*EventBus, chan message.Message, uint32) {
	eb := New()
	myChan := make(chan message.Message, 10)
	cl := NewChanListener(myChan)
	id := eb.Subscribe(topics.Tx, cl)
	assert.NotNil(t, id)
	m := GetTxMsg()
	errList := eb.Publish(topics.Tx, m)
	assert.Empty(t, errList)

	select {
	case received := <-myChan:
		assert.Equal(t, m, received)
	case <-time.After(50 * time.Millisecond):
		assert.FailNow(t, "We should have received a message by now")
	}

	return eb, myChan, id
}


*/
