package message

/*
import (
	"Levee/topics"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestMessageTx(t *testing.T) {
	fromAddr := [32]byte{0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	toAddr := [32]byte{0xbf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	tx := types.NewTransaction(fromAddr, toAddr, uint64(1000), uint64(10000))

	m := NewBlockchainMessage(topics.Tx, *tx)

	mBytes, err := m.MarshalBinary()
	assert.Nil(t, err)

	var newM BlockchainMessage
	newM.UnmarshalBinary(mBytes)

	//m.MarshalBinary()
	//newM.MarshalBinary()
	assert.Equal(t, m.Category(), newM.Category())
	assert.Equal(t, m.Payload(), newM.Payload())
}

func TestMessageBlock(t *testing.T) {
	fromAddr := [32]byte{0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	toAddr := [32]byte{0xbf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	tx1 := chaintype.NewTransaction(fromAddr, toAddr, uint64(1000), uint64(10000))
	tx2 := chaintype.NewTransaction(toAddr, fromAddr, uint64(1000), uint64(10000))

	txs := []chaintype.Transaction{*tx1, *tx2}

	prevHash := [32]byte{0xbf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	rootHash := [32]byte{0xba, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17}
	coinbase := [32]byte{0xba, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0xaf, 0xad, 0x12, 0x13, 0x14, 0x15, 0x16, 0x36}
	h := chaintype.NewBlockHeader(1, 1, prevHash, rootHash, coinbase, coinbase, uint64(time.Now().Unix()))

	blk := chaintype.NewBlock(*h, txs)

	m := NewBlockchainMessage(topics.Block, *blk)

	mBytes, err := m.MarshalBinary()
	assert.Nil(t, err)

	var newM BlockchainMessage
	newM.UnmarshalBinary(mBytes)

	//m.MarshalBinary()
	//newM.MarshalBinary()
	assert.Equal(t, m.Category(), newM.Category())
	assert.Equal(t, m.Payload(), newM.Payload())
}

*/
